%D \module
%D   [     file=t-syntax-groups,
%D      version=2012.05.06,
%D        title=\CONTEXT\ User Module,
%D     subtitle=Syntax highlighting support,
%D       author=Aditya Mahajan,
%D         date=\currentdate,
%D    copyright=Aditya Mahajan,
%D        email=adityam <at> ieee <dot> org,
%D      license=Simplified BSD License]

\writestatus{loading}{Syntax highlighting groups (ver: 2012.05.06)}

\startmodule [syntax-group]
\usemodule   [module-catcodes]

\unprotectmodulecatcodes

% Colors are specified in hex; in MkII the hex mode needs to be activated.
\doifmode\s!mkii
    {\setupcolor[hex]}


\def\colorscheme@name {}

\def\syntaxgroup@id          {syntaxgroup}
\def\syntaxgroup@namespace   {@@@@\syntaxgroup@id}
\def\syntaxgroup@name        {}

\edef\t!syntaxgroup           {\syntaxgroup@id}


\installparameterhandler  \syntaxgroup@namespace \syntaxgroup@id
\installsetuphandler      \syntaxgroup@namespace \syntaxgroup@id
\doifmode{\s!mkiv}
  {\installstyleandcolorhandler      \syntaxgroup@namespace \syntaxgroup@id}

\def\m!syntaxgroup{t-syntax-group}

\def\definesyntaxgroup
    {\dodoubleargument\syntaxgroup@define}

%% file handle used to create cssfile for each colorscheme defined
\newwrite \colorscheme@cssout

\startluacode
    -- helper methods
    -- TODO most likely to be shipped out to distinct *.lua file in
    -- production code. Done on advice.

    colorscheme = colorscheme or {} -- namespace handle
    settings_to_array = utilities.parsers.settings_to_array

    function scalechannel(val)
        -- converts context rgb and alpha channel values to 
        -- to css hex codeable values
        return math.min(math.round(val*255),255)
    end

    -- map used to translate context transparency mode numbers into corresponding
    -- css mix-blend-mode strings. Most modes and strings are identical
    -- some are written with hyphen inbetween. Two seem not to be supported
    -- they are mapped to the closest looking mode according to figure 1.6 in [1]
    -- on page 16 and preceeding table on page 15.
    --
    -- [1] Hagen Hans, Coloring ConTeXt explaining luatex and mkiv, PRAGMA ADE, 2016
    --     online: http://www.pragma-ade.com/general/manuals/colors-mkiv.pdf
    --
    blendmodemap = {
         [1] = "normal","multiply","screen","overlay",
         "luminosity","normal", -- mapped to closest supported by css
         "color-doge","color-burn","darken","lighten",
         "difference","exclusion","hue","saturation",
         "color","luminosity"
    }

	function colorscheme.cssformatcolor(str,transparency)
        -- converts colorvalue string and transparencycomponents string
        -- into proper css RGBA hex color value and mix-blend-mode value

        -- TODO maybe replace access to colorvalue and transparency 
        --      by access to public luainterface 
        --      this has to be done by somebody with more indeep luatex mkiv
        --      and lmtx/lmtx mkiv knowledge respective than me

		local colorvals = {} -- pars colorvalue string to get all components

        -- split colorvalue string
		for channel in string.gmatch(str,"([^%s]+)") do
            table.insert(colorvals,tonumber(channel))
        end

        local alphachannel = {} -- parsed component string if not empty

        -- split transparency string 
        -- currently is formated as a=<modenumber> st=<opacity value>
        -- TODO verify that a is mode and st is opacity and not vice versa
        for value in string.gmatch(transparency,"([^%s=]+)") do
            table.insert(alphachannel,tonumber(value))
        end
        -- select blend mode if alphachannel has at least the four elements
        -- ['a','<modenumber>','st','<opacity value>']
        -- directly output css mix-blend-mode attribute string to context
        -- and convert opacity number to alpha channel hex value
        if #alphachannel >= 4 and alphachannel[1] == "a" and alphachannel[3] == "st" then
            context("mix-blend-mode: ",blendmodemap[math.floor(alphachannel[2])])
            alphavalue = string.format("%02X",scalechannel(alphachannel[4]))
        end
 
        -- assemble css color attribute value dependent upon color model used to define
        -- context color. Model can be distinguished by number of entries in colorvals array
        -- #colorvals == 4 -> CMYK
        -- #colorvals == 3 -> RGB
        -- #colorvals == 2 -> ??? TODO how has more knowledge on this context color mode
        -- #colorvals == 1 -> grey/BW
        -- #colorvals < 1  -> invalid: black
        -- #colorvals > 4  -> invalid: black
        --
        -- append alphavalue string if not empty and output resulting string to context
        context("color: ")
        context.letterhash()
        if #colorvals == 3 then
			context("%02X%02X%02X%s;",scalechannel(colorvals[1]),scalechannel(colorvals[2]),scalechannel(colorvals[3]),alphavalue)
        elseif #colorvals == 4 then
            brightness = 1-colorvals[4]
			context("%02X%02X%02X%s;",scalechannel((1-colorvals[1])*brightness),scalechannel((1-colorvals[2])*brightness),scalechannel((1-colorvals[3]) * brightness,alphavalue ))
        elseif #colorvals == 1 then
            colorvals[1] = scalechannel(colorvals[1])
            context("%02X%02X%02X%s;",colorvals[1],colorvals[1],colorvals[1],alphavalue)
        else
            context("000000%s",alphavalue)
        end
    end

    local reporter = logs.reporter("module","t-vim")

    function verify_css_styles_path(jobname)
        local exportpath = string.format("%s-export",jobname)
        if not lfs.isdir(exportpath) then
            lfs.mkdir(exportpath)
            if not lfs.isdir(exportpath) then
                 return "."
            end
		end
        local stylespath = file.join(exportpath,"styles")
        if not lfs.isdir(stylespath) then
            lfs.mkdir(stylespath)
            if not lfs.isdir(stylespath) then
                 return exportpath
            end
		end
        return stylespath
    end

    function colorscheme.css_export_path(jobname,name)
         -- assembles proper path for storing css file for colorsceme 
         -- TODO likely could also be done in context directly but failed to make it work as expected
         context(file.join(verify_css_styles_path(jobname),jobname.."-t-syntaxgroup-".. name ..".css"))
    end

    function colorscheme.append_css_file(l,jobname,name)
        -- appends colorscheme css file into cssfile export parameter
        -- this is called when a new vimtyping environment is defined to ensure
        -- that the exporter consideres the appropriate cssfile for the selected
        -- colorscheme.

        -- split content of cssfile export parameter into list of individual file names
        local currentcssfiles = settings_to_array(l,false)

        -- path to css file for colorscheme denoted by name
        local cssfilepath = jobname.."-t-syntaxgroup-".. name ..".css"
        if not table.contains(currentcssfiles,cssfilepath) then
            -- insert colorschem css file into list and output resulting string to
            -- context
        	table.insert(currentcssfiles,cssfilepath)
        	l = table.concat(table.unique(currentcssfiles),", ")
		end
        context("%s",l)
    end

\stopluacode

\def\colorscheme@formatcolor#1#2{\ctxlua{colorscheme.cssformatcolor("#1","#2","\letterhash")}}

\starttexdefinition colorscheme@output_css_yes#1#2#3#4#5 
    % #1 ... colorscheme name
    % #2 ... syntaxgroup id
    % #3 ... \syntaxgroupparameter\c!color
    % #4 ... \syntaxgroupparameter\c!style
    % #5 ... \syntaxgroupparameter\c!command
    % helper method to write css sections for each syntaxgroup defined for 
    % a specific colorscheme.
    % exporter generates xml tag based xhtml (postfix: -tag) and html tag based xhtml (postifx: -div)
    % css file selectors have to be formulated for both formats. to avoid unecessary duplication
    % both are listed as alternative for ach other. see css spec for details 
    \immediate\write\colorscheme@cssout{\syntaxhighlighting@id[detail=#1] \syntaxgroup@id[detail=#2], .\syntaxhighlighting@id.#1 .\syntaxgroup@id.#2 \letteropenbrace}
    \doifsomething{\colorvalue{#3}}{
         \immediate\write\colorscheme@cssout{\colorscheme@formatcolor{\colorvalue{#3}}{\transparencycomponents{#3}}}
    }
    \doifsomething{#4}{
         % for now just print content of style value and assume css understnads it
         % TODO better would be if style would be properly parsed and all found attributes set individually or
         % reassembled to proper css font style string
         \immediate\write\colorscheme@cssout{    font\lettercolon #4;}
    }
    \doifsomething{#5}{%
         % for now just \underbar and \overbar are considered.
         \doifelse{#5}{\underbar}{%
             \immediate\write\colorscheme@cssout{    text-decoration\lettercolon underline;}
        }{%
             \doifelse{#5}{\overbar}{%
                  \immediate\write\colorscheme@cssout{    text-decoration\lettercolon overline;}
             }{%
                 % TODO check for other relevant commands or decendants of framed and properly mapp their values
                 % corresponding css attributes
             }%
         }%
    }
    \immediate\write\colorscheme@cssout{\letterclosebrace}
\stoptexdefinition

% if export mode is active output css sections else do nothing 
\doifmodeelse{*export}{
   \let\colorscheme@output_css\colorscheme@output_css_yes
}{
   \def\colorscheme@output_css#1#2#3#4#5{}
}


\starttexdefinition syntaxgroup@define [#1][#2]
  % #1 list name
  % #2 options
  \doifassignmentelse{#2}
  {
    \def\syntaxgroup@get_parameters##1%
    {
         \edef\syntaxgroup@name {\colorscheme@name##1}
         \setupsyntaxgroup[\syntaxgroup@name]
                          [\s!parent=\syntaxgroup@namespace,\c!color=,\c!style=,\c!command=,#2]
         \doifsomething{\syntaxgroupparameter\c!color}
          {
             \expanded{\definecolor[\syntaxgroup@namespace-##1-color]
                                   [\syntaxgroupparameter\c!color]}
             \setupsyntaxgroup[\syntaxgroup@name][\s!parent=\syntaxgroup@namespace,\c!color=\syntaxgroup@namespace-##1-color]
          }
          \colorscheme@output_css{\colorscheme@name}{##1}{\syntaxgroupparameter\c!color}{\syntaxgroupparameter\c!style}{\syntaxgroupparameter\c!command}
    }
  }{
    \def\syntaxgroup@get_parameters##1%
    {
        \edef\syntaxgroup@name {\colorscheme@name##1}
        \expanded{\setupsyntaxgroup[\syntaxgroup@name]
                         [\c!color=\namedsyntaxgroupparameter{\colorscheme@name#2}\c!color,
                          \c!style=\namedsyntaxgroupparameter{\colorscheme@name#2}\c!style,
                        \c!command=\namedsyntaxgroupparameter{\colorscheme@name#2}\c!command,
                         ]}

        \colorscheme@output_css{\colorscheme@name}{##1}{\syntaxgroupparameter\c!color}{\syntaxgroupparameter\c!style}{\syntaxgroupparameter\c!command}
        % In MkII, \expanded messes up the definition of \currentsyntaxgroup
        \def\currentsyntaxgroup   {\syntaxgroup@name}
    }
  }
  \processcommalist[#1]\syntaxgroup@get_parameters
\stoptexdefinition

\def\startcolorscheme%
    {\dosingleargument\colorscheme@start}

\starttexdefinition colorscheme@output_css_header#1#2#3
     % first two sections in colorscheme css set display style of 
     % syntaxhighlightingd and syntaxlinegroup tags therin
     % for syntaxlinegroup tags in addition the white-space attribute is set
     % to pre-wrap
     % TODO switch between pre-wrap and pre dependent uppon 
     %      \syntaxhighlightingparameter\c!lines and
     %      \syntaxhighlightingparameter\c!option
     %
     \immediate\write\colorscheme@cssout{#1[detail=#2], .#1.#2 \letteropenbrace}
     \immediate\write\colorscheme@cssout{    display\lettercolon inline;}
     \immediate\write\colorscheme@cssout{\letterclosebrace} 
     \immediate\write\colorscheme@cssout{#1[detail=#2] #3, .#1.#2 .#3 \letteropenbrace}
     \immediate\write\colorscheme@cssout{    display\lettercolon inline;}
     \immediate\write\colorscheme@cssout{    white-space\lettercolon pre-wrap;}
     \immediate\write\colorscheme@cssout{\letterclosebrace} 
\stoptexdefinition

\starttexdefinition colorscheme@start [#1]
     \pushmacro\colorscheme@name
     \setcolorscheme{#1}
     %\setupsyntaxgroup[\c!color=,\c!style=,\c!command=]
     \doifmode{*export}{
         % create css file for this colorsceme 
         \setcssfilename{\jobname}{\colorscheme@name}
         \writestatus{colorscheme}{cssfile: \colorscheme@css_file}
         \writestatus{colorscheme}{export: \exportparameter\c!cssfile}
         \writestatus{colorscheme}{expected: \jobname-templates.css}
         \writestatus{colorscheme}{title: \exportparameter\c!title}
         \immediate\openout \colorscheme@cssout \colorscheme@css_file
         \colorscheme@output_css_header{\syntaxhighlighting@id}{\colorscheme@name}{\syntaxlinegroup@id}\relax
     }    
\stoptexdefinition

\def\stopcolorscheme{\colorscheme@stop}

\starttexdefinition colorscheme@stop
    \doifmode{*export}{
        % all syntax groups relevant to this colorscheme are defined close css file
        \immediate\closeout \colorscheme@cssout
    }
    \popmacro\colorscheme@name
\stoptexdefinition

\def\colorscheme@css_file{}
\def\setcssfilename#1#2%
{
 \edef\colorscheme@css_file{\ctxlua{colorscheme.css_export_path("#1","#2")}}
}

\starttexdefinition colorscheme@setup_export#1
    % color scheme is used by a newly define vimtyping environment
    % ensure that the css file for the selected colorschme is included
    % into the list of css files considered by the exporter through
    % the \exportparameter\c!cssfile parameter
    \writestatus{colorscheme}{setup cssfile}
    \doifmode{*export}{
        \def\inject_css_file##1##2{
            \writestatus{colorscheme}{current: ##1 jobname ##2 scheme {#1}}
            \edef\extended_css_file_list{\ctxlua{colorscheme.append_css_file("##1","##2","#1")}}
            \writestatus{colorscheme}{extended css: \extended_css_file_list}
            \setupexport[cssfile={\extended_css_file_list}]
            % exporter works a bit differnt it has its' own hardcoded setup routine
            % which is called on every \startdocument \starttext \startproject etc. call
            % the nasty thing about is that \dosynchronizeexport empties the \currentexport
            % macro therefor a new call to \setupexport has not effect unless \dosynchronizeexport
            % is called immediately afterwards to update current setup stored internally in lua only
            \dosynchronizeexport
        }
        \inject_css_file{\exportparameter\c!cssfile}{\jobname}
    }
\stoptexdefinition

\def\setcolorscheme#1%
    {\edef\colorscheme@name{#1}}

\starttexdefinition syntaxgroup [#1]#2
  % #1 = style
  % #2 = content
      \begingroup
      \edef\syntaxgroup@name{\colorscheme@name#1}%
      \syntaxgroupparameter\c!before
      \iftracesyntaxgroups
          \syntaxgroup@show_values
      \fi
      \doifmode{\s!mkiv}{\dostarttagged\t!syntaxgroup{#1}}
      \syntaxgroupparameter\c!command
      {
        \externalfilter@attributes_start\syntaxgroup@id\c!style\c!color
            #2
        \externalfilter@attributes_stop
      }
      \doifmode{\s!mkiv}{\dostoptagged}
      \syntaxgroupparameter\c!after
      \endgroup
\stoptexdefinition

%D Tracing macros

\newif\iftracesyntaxgroups
\let\tracesyntaxgroups\tracesyntaxgroupstrue

\def\currentsyntaxgroup   {\syntaxgroup@name}

\starttexdefinition syntaxgroup@show_values
  \writestatus\m!syntaxgroup{color scheme : \colorscheme@name}
  \writestatus\m!syntaxgroup{current group: \syntaxgroup@name}
  \writestatus\m!syntaxgroup{command      : \syntaxgroupparameter\c!command}
  \writestatus\m!syntaxgroup{style        : \syntaxgroupparameter\c!style}
  \writestatus\m!syntaxgroup{color        : \syntaxgroupparameter\c!color}
\stoptexdefinition

\protectmodulecatcodes
\stopmodule
